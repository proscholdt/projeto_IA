<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Chatbot RAG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; background:#0b1117; color:#e6edf3; }
    .wrap { max-width: 860px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin-bottom: 12px; }
    .chat { background: #0d1117; border: 1px solid #30363d; border-radius: 12px; padding: 16px; min-height: 420px; }
    .msg { margin: 10px 0; padding: 12px 14px; border-radius: 12px; max-width: 80%; white-space: pre-wrap; }
    .user { background:#1f6feb22; border:1px solid #1f6feb55; margin-left:auto; }
    .assistant { background:#161b22; border:1px solid #30363d; }
    .meta { font-size:12px; color:#8b949e; margin-top:6px; }
    .row { display:flex; gap:8px; margin-top:12px; }
    textarea { flex:1; resize:vertical; min-height:60px; background:#0d1117; color:#e6edf3; border:1px solid #30363d; border-radius:8px; padding:10px; }
    button { background:#238636; color:white; border:0; border-radius:8px; padding:10px 16px; cursor:pointer; }
    button.secondary { background:#30363d; }

    /* Botão de microfone */
    #mic {
      background:#30363d;
      display:flex; align-items:center; gap:8px;
    }
    #mic.recording {
      background:#d93025;
      animation: pulse 1.2s ease-in-out infinite;
    }
    #mic svg { width:18px; height:18px; }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(217,48,37,0.5); }
      70% { box-shadow: 0 0 0 10px rgba(217,48,37,0); }
      100% { box-shadow: 0 0 0 0 rgba(217,48,37,0); }
    }

    .badge { display:inline-block; background:#1f6feb22; color:#58a6ff; border:1px solid #1f6feb55; border-radius:999px; padding:2px 8px; font-size:12px; margin-left:6px; }
    footer { position: fixed; bottom: 0; width: 100%; padding: 8px 0; background-color: #0b1117; color: #93a4c3; font-size: 14px; border-top: 1px solid #1e2a42; text-align: center; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Chatbot RAG <span id="cat" class="badge" style="display:none;"></span></h1>

    <div id="chat" class="chat"></div>

    <div class="row">
      <textarea id="msg" placeholder="Digite sua mensagem..."></textarea>
      <!-- NOVO: Botão de microfone -->
      <button id="mic" title="Falar para transcrever (pt-BR)">
        <!-- ícone mic (SVG inline) -->
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zM11 19.93V22h2v-2.07a8.001 8.001 0 0 0 6.928-6.928H17A6 6 0 0 1 7 13.07H4.072A8.001 8.001 0 0 0 11 19.93z"/>
        </svg>
        <span id="mic-label">Falar</span>
      </button>
      <button id="send">Enviar</button>
      <button id="reset" class="secondary" title="Reiniciar conversa">Reiniciar</button>
    </div>
  </div>

  <footer>Developed by Henrique Proscholdt</footer>

  <script>
    const API_CHAT = "/api/chat/message";
    const API_RESET = "/api/chat/reset";
    const chatEl = document.getElementById("chat");
    const inputEl = document.getElementById("msg");
    const sendBtn = document.getElementById("send");
    const resetBtn = document.getElementById("reset");
    const micBtn = document.getElementById("mic");
    const micLabel = document.getElementById("mic-label");
    const catEl = document.getElementById("cat");

    let sessionId = localStorage.getItem("chat_session_id") || null;

    function appendUser(text){
      const div = document.createElement("div");
      div.className = "msg user";
      div.textContent = text;
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    function appendAssistant(answer, fontes, categoria){
      const div = document.createElement("div");
      div.className = "msg assistant";
      div.innerHTML = `${answer}`;
      chatEl.appendChild(div);

      if (categoria) {
        catEl.style.display = 'inline-block';
        catEl.textContent = categoria;
      }

      if (Array.isArray(fontes) && fontes.length) {
        const d = document.createElement("details");
        const s = document.createElement("summary");
        s.textContent = `Ver fontes (${fontes.length})`;
        d.appendChild(s);

        fontes.forEach((f, i) => {
          const p = document.createElement("div");
          p.className = "meta";
          p.innerHTML = `<strong>${i+1}. ${f.titulo || "(Sem título)"} – <em>${f.categoria || "-"}</em></strong><br>${f.trecho || ""}`;
          d.appendChild(p);
        });

        chatEl.appendChild(d);
      }

      chatEl.scrollTop = chatEl.scrollHeight;
    }

    async function send(){
      const text = (inputEl.value || "").trim();
      if (!text) return;
      appendUser(text);
      inputEl.value = "";
      sendBtn.disabled = true;

      try {
        const res = await fetch(API_CHAT, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({ message: text, session_id: sessionId })
        });
        if (!res.ok) throw new Error("Falha na requisição");
        const data = await res.json();

        if (data.session_id) {
          sessionId = data.session_id;
          localStorage.setItem("chat_session_id", sessionId);
        }

        appendAssistant(data.resposta || "Sem resposta.", data.fontes || [], data.categoria || null);
      } catch (e) {
        appendAssistant("❌ Erro ao obter resposta. Tente novamente.", [], null);
        console.error(e);
      } finally {
        sendBtn.disabled = false;
        inputEl.focus();
      }
    }

    async function reset(){
      if (!sessionId) {
        chatEl.innerHTML = ""; 
        catEl.style.display = 'none';
        return;
      }
      try {
        await fetch(`${API_RESET}?session_id=${encodeURIComponent(sessionId)}`, { method: "POST" });
      } catch {}
      localStorage.removeItem("chat_session_id");
      sessionId = null;
      chatEl.innerHTML = "";
      catEl.style.display = 'none';
      inputEl.focus();
    }

    sendBtn.addEventListener("click", send);
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });
    resetBtn.addEventListener("click", reset);

    // ===== Reconhecimento de voz (Web Speech API) =====
    // Suporte (Chrome/Edge usam webkitSpeechRecognition)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;
    let baseTextAtStart = ""; // conteúdo que já estava no textarea quando começou a gravar

    function setMicState(recording) {
      isRecording = recording;
      micBtn.classList.toggle("recording", recording);
      micLabel.textContent = recording ? "Gravando…" : "Falar";
      micBtn.title = recording ? "Clique para parar" : "Falar para transcrever (pt-BR)";
    }

    if (!SpeechRecognition) {
      // Sem suporte: desabilita botão
      micBtn.disabled = true;
      micBtn.title = "Reconhecimento de voz não suportado neste navegador";
    } else {
      recognition = new SpeechRecognition();
      recognition.lang = "pt-BR";
      recognition.interimResults = true;   // resultados parciais (vai preenchendo)
      recognition.continuous = true;       // continua ouvindo até parar

      recognition.onstart = () => setMicState(true);

      recognition.onerror = (e) => {
        console.error("Speech error:", e.error);
        setMicState(false);
      };

      recognition.onend = () => {
        // encerrou naturalmente (tempo sem fala) ou pelo usuário
        setMicState(false);
      };

      recognition.onresult = (event) => {
        // Monta texto a partir dos resultados
        let interim = "";
        let finalTranscript = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          if (res.isFinal) {
            finalTranscript += res[0].transcript;
          } else {
            interim += res[0].transcript;
          }
        }

        // Atualiza o textarea sem perder o que já existia
        const sep = baseTextAtStart && !baseTextAtStart.endsWith(" ") ? " " : "";
        inputEl.value = (baseTextAtStart + sep + finalTranscript + (interim ? " " + interim : "")).trimStart();
        inputEl.focus();
        inputEl.selectionStart = inputEl.selectionEnd = inputEl.value.length; // cursor no fim
      };

      micBtn.addEventListener("click", () => {
        if (isRecording) {
          recognition.stop();
          return;
        }
        try {
          baseTextAtStart = inputEl.value || "";
          recognition.start();
        } catch (err) {
          // Alguns navegadores dão erro se chamar start duas vezes
          console.error("Não foi possível iniciar o reconhecimento:", err);
        }
      });
    }
  </script>
</body>
</html>
